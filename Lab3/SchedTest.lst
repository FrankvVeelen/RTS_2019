
SchedTest.elf:     file format elf32-msp430

SYMBOL TABLE:
00004000 l    d  .text	00000000 .text
00001100 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
0000482e l    d  .debug_ranges	00000000 .debug_ranges
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000050 l       *ABS*	00000000 I2CIE
00000051 l       *ABS*	00000000 I2CIFG
00000052 l       *ABS*	00000000 I2CNDAT
00000071 l       *ABS*	00000000 I2CTCTL
00000072 l       *ABS*	00000000 I2CDCTL
00000073 l       *ABS*	00000000 I2CPSC
00000074 l       *ABS*	00000000 I2CSCLH
00000075 l       *ABS*	00000000 I2CSCLL
00000076 l       *ABS*	00000000 I2CDRB
00000076 l       *ABS*	00000000 I2CDRW
00000118 l       *ABS*	00000000 I2COA
0000011a l       *ABS*	00000000 I2CSA
0000011c l       *ABS*	00000000 I2CIV
00000076 l       *ABS*	00000000 I2CDR
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
00000055 l       *ABS*	00000000 SVSCTL
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
000001c0 l       *ABS*	00000000 DAC12_0CTL
000001c2 l       *ABS*	00000000 DAC12_1CTL
000001c8 l       *ABS*	00000000 DAC12_0DAT
000001ca l       *ABS*	00000000 DAC12_1DAT
00000122 l       *ABS*	00000000 DMACTL0
00000124 l       *ABS*	00000000 DMACTL1
000001e0 l       *ABS*	00000000 DMA0CTL
000001e2 l       *ABS*	00000000 DMA0SA
000001e4 l       *ABS*	00000000 DMA0DA
000001e6 l       *ABS*	00000000 DMA0SZ
000001e8 l       *ABS*	00000000 DMA1CTL
000001ea l       *ABS*	00000000 DMA1SA
000001ec l       *ABS*	00000000 DMA1DA
000001ee l       *ABS*	00000000 DMA1SZ
000001f0 l       *ABS*	00000000 DMA2CTL
000001f2 l       *ABS*	00000000 DMA2SA
000001f4 l       *ABS*	00000000 DMA2DA
000001f6 l       *ABS*	00000000 DMA2SZ
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000004 l       *ABS*	00000000 ME1
00000005 l       *ABS*	00000000 ME2
00000000 l    df *ABS*	00000000 SchedTest.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Led.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Clock.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Context.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001100 l     O .bss	00000001 CurrentContext
00001102 l     O .bss	00000003 Contexts
00000000 l    df *ABS*	00000000 SchedulerOnline.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Scheduler_NP_FP.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001106 l     O .bss	00000001 Busy.1740
00000000 l    df *ABS*	00000000 Scheduler_P_FP.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Scheduler_P_EDF.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Scheduler_NP_EDF.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001107 l     O .bss	00000001 Busy.1754
00000000 l    df *ABS*	00000000 TimeTracking.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001108 l     O .bss	00000004 StartTimes
0000110c l     O .bss	00000004 Totals
00001110 l     O .bss	00000001 JobsExecuted
00000000 l    df *ABS*	00000000 memcpy.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 g       *ABS*	00000000 __data_size
0000423c g     F .text	00000084 RegisterTask
000041d6 g     F .text	00000016 ResumeContext
000041a6 g     F .text	00000018 InitClock
0000469e g     F .text	0000000c StartTracking
00004186 g     F .text	0000000a InitLeds
00004036 g     F .text	00000018 CountDelay
0000482e g       .text	00000000 _etext
00000044 g       *ABS*	00000000 __bss_size
000046c0 g     F .text	00000006 AddJobExecution
00004030 g       .text	00000000 _unexpected_1_
000046f2 g     F .text	0000013c memcpy
00004030  w      .text	00000000 vector_ffe0
0000437c g     F .text	000000a0 Scheduler_NP_FP
000045a8 g     F .text	000000f6 Scheduler_NP_EDF
0000441c g     F .text	00000092 Scheduler_P_FP
000044ae g     F .text	000000fa Scheduler_P_EDF
000042d4 g       .text	00000000 vector_ffec
00004030  w      .text	00000000 vector_fff0
0000482e g       *ABS*	00000000 __data_load_start
00004030 g       .text	00000000 __dtors_end
00004030  w      .text	00000000 vector_fffc
0000414a g     F .text	0000003c BlinkYellow
00004030  w      .text	00000000 vector_ffe4
000041a0 g     F .text	00000006 ToggleLeds
00004190 g     F .text	00000010 SetLeds
0000ffe0 g     O .vectors	00000020 InterruptVectors
000042c0 g     F .text	00000014 UnRegisterTask
000041be g     F .text	00000018 ContextSwitch
0000410e g     F .text	0000003c BlinkGreen
0000401c  w      .text	00000000 __do_clear_bss
000042d4 g     F .text	000000a8 TimerIntrpt
00004030  w      .text	00000000 vector_ffe2
00004030  w      .text	00000000 vector_ffe8
00004034  w      .text	00000000 _unexpected_
00004030  w      .text	00000000 vector_fffa
00001112 g     O .bss	00000030 Tasks
00004000  w      .text	00000000 _reset_vector__
00004030 g       .text	00000000 __ctors_start
0000400a  w      .text	00000000 __do_copy_data
0000404e g     F .text	00000020 CountRealtimeDelay
00001100 g       .bss	00000000 __bss_start
00004030  w      .text	00000000 vector_ffee
00004030  w      .text	00000000 vector_fff4
0000406e g     F .text	00000064 main
00004030  w      .text	00000000 vector_fff8
000046c6 g     F .text	0000002c PrintResults
00004030  w      .text	00000000 vector_fff2
000040d2 g     F .text	0000003c BlinkRed
00010000 g       .vectors	00000000 _vectors_end
00004030  w      .text	00000000 vector_ffe6
000041ec g     F .text	00000006 IntDisable
00001142 g     O .bss	00000002 NextInterruptTime
00004000  w      .text	00000000 __init_stack
00004030 g       .text	00000000 __dtors_start
00004030 g       .text	00000000 __ctors_end
00003900 g       *ABS*	00000000 __stack
00001100 g       .bss	00000000 _edata
00001144 g       .bss	00000000 _end
00004030  w      .text	00000000 vector_fff6
00004004  w      .text	00000000 __low_level_init
0000402c  w      .text	00000000 __jump_to_main
000041f6 g     F .text	00000046 InitTasks
00001100 g       .bss	00000000 __data_start
00004030  w      .text	00000000 vector_ffea
000046aa g     F .text	00000016 StopTracking
000041f2 g     F .text	00000004 RestoreSW



Disassembly of section .text:

00004000 <__init_stack>:
    4000:	31 40 00 39 	mov	#14592,	r1	;#0x3900

00004004 <__low_level_init>:
    4004:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    4008:	20 01 

0000400a <__do_copy_data>:
    400a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    400e:	0f 93       	tst	r15		
    4010:	05 24       	jz	$+12     	;abs 0x401c
    4012:	2f 83       	decd	r15		
    4014:	9f 4f 2e 48 	mov	18478(r15),4352(r15);0x482e(r15), 0x1100(r15)
    4018:	00 11 
    401a:	fb 23       	jnz	$-8      	;abs 0x4012

0000401c <__do_clear_bss>:
    401c:	3f 40 44 00 	mov	#68,	r15	;#0x0044
    4020:	0f 93       	tst	r15		
    4022:	04 24       	jz	$+10     	;abs 0x402c
    4024:	1f 83       	dec	r15		
    4026:	cf 43 00 11 	mov.b	#0,	4352(r15);r3 As==00, 0x1100(r15)
    402a:	fc 23       	jnz	$-6      	;abs 0x4024

0000402c <__jump_to_main>:
    402c:	30 40 6e 40 	br	#0x406e	

00004030 <__ctors_end>:
    4030:	30 40 34 40 	br	#0x4034	

00004034 <_unexpected_>:
    4034:	00 13       	reti			

00004036 <CountDelay>:
#define YELLOWBLINKPRIO 0
#define GREENBLINKPRIO  1
#define REDBLINKPRIO    2

void CountDelay (volatile uint16_t cnt)
{
    4036:	21 83       	decd	r1		
    4038:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  while (cnt--);
    403c:	2f 41       	mov	@r1,	r15	
    403e:	0e 4f       	mov	r15,	r14	
    4040:	3e 53       	add	#-1,	r14	;r3 As==11
    4042:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    4046:	0f 93       	tst	r15		
    4048:	f9 23       	jnz	$-12     	;abs 0x403c
}
    404a:	21 53       	incd	r1		
    404c:	30 41       	ret			

0000404e <CountRealtimeDelay>:
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    404e:	0f 5f       	rla	r15		
    4050:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    4052:	1d 42 70 01 	mov	&0x0170,r13	
    4056:	0e 43       	clr	r14		
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4058:	07 3c       	jmp	$+16     	;abs 0x4068
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    405a:	1c 42 70 01 	mov	&0x0170,r12	
    405e:	0d 9c       	cmp	r12,	r13	
    4060:	fc 27       	jz	$-6      	;abs 0x405a
    {
      TicksPassed++; // increment ticks counter
    4062:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    4064:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4068:	0e 9f       	cmp	r15,	r14	
    406a:	f7 2b       	jnc	$-16     	;abs 0x405a
    {
      TicksPassed++; // increment ticks counter
      OldTAR = TAR; // store new value of TAR as old value
    }
  }
}
    406c:	30 41       	ret			

0000406e <main>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (RED, 0);
}

int main(void) 
{ 
    406e:	31 40 00 39 	mov	#14592,	r1	;#0x3900
  WDTCTL = WDTPW + WDTHOLD;       // Stop watchdog timer 
    4072:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    4076:	20 01 
  
  InitClock ();
    4078:	b0 12 a6 41 	call	#0x41a6	

  InitLeds (RED | GREEN | YELLOW | WHITE | BROWN | PURPLE);
    407c:	7f 40 77 00 	mov.b	#119,	r15	;#0x0077
    4080:	b0 12 86 41 	call	#0x4186	

#define Tst1

#ifdef Tst1
  // note: there 1024 ticks in second
  RegisterTask (0, 1024, 350, BlinkYellow, YELLOWBLINKPRIO, 0); 
    4084:	43 12       	push.b	#0		;r3 As==00
    4086:	43 12       	push.b	#0		;r3 As==00
    4088:	3c 40 4a 41 	mov	#16714,	r12	;#0x414a
    408c:	3d 40 5e 01 	mov	#350,	r13	;#0x015e
    4090:	3e 40 00 04 	mov	#1024,	r14	;#0x0400
    4094:	0f 43       	clr	r15		
    4096:	b0 12 3c 42 	call	#0x423c	
  RegisterTask (0, 512, 140, BlinkGreen, GREENBLINKPRIO, 0);
    409a:	43 12       	push.b	#0		;r3 As==00
    409c:	53 12       	push.b	#1		;r3 As==01
    409e:	3c 40 0e 41 	mov	#16654,	r12	;#0x410e
    40a2:	3d 40 8c 00 	mov	#140,	r13	;#0x008c
    40a6:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    40aa:	0f 43       	clr	r15		
    40ac:	b0 12 3c 42 	call	#0x423c	
  RegisterTask (0, 256, 30, BlinkRed, REDBLINKPRIO, 0);
    40b0:	43 12       	push.b	#0		;r3 As==00
    40b2:	63 12       	push.b	#2		;r3 As==10
    40b4:	3c 40 d2 40 	mov	#16594,	r12	;#0x40d2
    40b8:	3d 40 1e 00 	mov	#30,	r13	;#0x001e
    40bc:	3e 40 00 01 	mov	#256,	r14	;#0x0100
    40c0:	0f 43       	clr	r15		
    40c2:	b0 12 3c 42 	call	#0x423c	
  RegisterTask (0, 128, 5, BlinkRed, 8, 0);
  RegisterTask (0, 256, 2, BlinkRed, 9, 0);
#endif


  _EINT();                        // Enable interrupts
    40c6:	32 d2       	eint			
    40c8:	31 50 0c 00 	add	#12,	r1	;#0x000c

  while(1) {
    EnterLowPowerMode3(); // idle task, set to low power mode 3 
    40cc:	32 c0 d0 00 	bic	#208,	r2	;#0x00d0
    40d0:	fd 3f       	jmp	$-4      	;abs 0x40cc

000040d2 <BlinkRed>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (GREEN, 0);
}

void BlinkRed (uint16_t ExecutionTime)
{
    40d2:	0b 12       	push	r11		
    40d4:	0b 4f       	mov	r15,	r11	
  SetLeds (RED, 1);
    40d6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    40d8:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    40dc:	b0 12 90 41 	call	#0x4190	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    40e0:	0f 4b       	mov	r11,	r15	
    40e2:	0f 5f       	rla	r15		
    40e4:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    40e6:	1d 42 70 01 	mov	&0x0170,r13	
    40ea:	0e 43       	clr	r14		
    40ec:	07 3c       	jmp	$+16     	;abs 0x40fc
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    40ee:	1c 42 70 01 	mov	&0x0170,r12	
    40f2:	0d 9c       	cmp	r12,	r13	
    40f4:	fc 27       	jz	$-6      	;abs 0x40ee
    {
      TicksPassed++; // increment ticks counter
    40f6:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    40f8:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    40fc:	0e 9f       	cmp	r15,	r14	
    40fe:	f7 2b       	jnc	$-16     	;abs 0x40ee

void BlinkRed (uint16_t ExecutionTime)
{
  SetLeds (RED, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (RED, 0);
    4100:	4e 43       	clr.b	r14		
    4102:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    4106:	b0 12 90 41 	call	#0x4190	
}
    410a:	3b 41       	pop	r11		
    410c:	30 41       	ret			

0000410e <BlinkGreen>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (YELLOW, 0);
}

void BlinkGreen (uint16_t ExecutionTime)
{
    410e:	0b 12       	push	r11		
    4110:	0b 4f       	mov	r15,	r11	
  SetLeds (GREEN, 1);
    4112:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4114:	7f 40 20 00 	mov.b	#32,	r15	;#0x0020
    4118:	b0 12 90 41 	call	#0x4190	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    411c:	0f 4b       	mov	r11,	r15	
    411e:	0f 5f       	rla	r15		
    4120:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    4122:	1d 42 70 01 	mov	&0x0170,r13	
    4126:	0e 43       	clr	r14		
    4128:	07 3c       	jmp	$+16     	;abs 0x4138
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    412a:	1c 42 70 01 	mov	&0x0170,r12	
    412e:	0d 9c       	cmp	r12,	r13	
    4130:	fc 27       	jz	$-6      	;abs 0x412a
    {
      TicksPassed++; // increment ticks counter
    4132:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    4134:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4138:	0e 9f       	cmp	r15,	r14	
    413a:	f7 2b       	jnc	$-16     	;abs 0x412a

void BlinkGreen (uint16_t ExecutionTime)
{
  SetLeds (GREEN, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (GREEN, 0);
    413c:	4e 43       	clr.b	r14		
    413e:	7f 40 20 00 	mov.b	#32,	r15	;#0x0020
    4142:	b0 12 90 41 	call	#0x4190	
}
    4146:	3b 41       	pop	r11		
    4148:	30 41       	ret			

0000414a <BlinkYellow>:
    }
  }
}

void BlinkYellow (uint16_t ExecutionTime)
{
    414a:	0b 12       	push	r11		
    414c:	0b 4f       	mov	r15,	r11	
  SetLeds (YELLOW, 1);
    414e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4150:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    4154:	b0 12 90 41 	call	#0x4190	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    4158:	0f 4b       	mov	r11,	r15	
    415a:	0f 5f       	rla	r15		
    415c:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    415e:	1d 42 70 01 	mov	&0x0170,r13	
    4162:	0e 43       	clr	r14		
    4164:	07 3c       	jmp	$+16     	;abs 0x4174
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    4166:	1c 42 70 01 	mov	&0x0170,r12	
    416a:	0d 9c       	cmp	r12,	r13	
    416c:	fc 27       	jz	$-6      	;abs 0x4166
    {
      TicksPassed++; // increment ticks counter
    416e:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    4170:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4174:	0e 9f       	cmp	r15,	r14	
    4176:	f7 2b       	jnc	$-16     	;abs 0x4166

void BlinkYellow (uint16_t ExecutionTime)
{
  SetLeds (YELLOW, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (YELLOW, 0);
    4178:	4e 43       	clr.b	r14		
    417a:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    417e:	b0 12 90 41 	call	#0x4190	
}
    4182:	3b 41       	pop	r11		
    4184:	30 41       	ret			

00004186 <InitLeds>:
#include <iomacros.h>
#include "Led.h"

void InitLeds (uint8_t Colors)
{
  LEDDIR |= Colors;
    4186:	c2 df 32 00 	bis.b	r15,	&0x0032	
  LEDPIN = 0;
    418a:	c2 43 31 00 	mov.b	#0,	&0x0031	;r3 As==00
}
    418e:	30 41       	ret			

00004190 <SetLeds>:

void SetLeds (uint8_t Colors, uint8_t On)
{
  if (On) LEDPIN |= Colors;
    4190:	4e 93       	tst.b	r14		
    4192:	03 24       	jz	$+8      	;abs 0x419a
    4194:	c2 df 31 00 	bis.b	r15,	&0x0031	
    4198:	30 41       	ret			
  else    LEDPIN &= ~Colors;
    419a:	c2 cf 31 00 	bic.b	r15,	&0x0031	
    419e:	30 41       	ret			

000041a0 <ToggleLeds>:
}

void ToggleLeds (uint8_t Colors)
{
  LEDPIN ^= Colors;
    41a0:	c2 ef 31 00 	xor.b	r15,	&0x0031	
}
    41a4:	30 41       	ret			

000041a6 <InitClock>:

#define ACLOCK    32768  /* rate of the Aclock                               */

void InitClock (void)
{
	TACTL  = TASSEL0 + TACLR + ID0 + ID1 + TAIE; /* ACLK, clear TAR, set clock divider at 8 */
    41a6:	b2 40 c6 01 	mov	#454,	&0x0160	;#0x01c6
    41aa:	60 01 
	TACCR0   = 0;  /* start first interrupt right away     */
    41ac:	82 43 72 01 	mov	#0,	&0x0172	;r3 As==00
	TACCTL0  = CCIE;            /* CCR0 interrupt enabled                        */
    41b0:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    41b4:	62 01 
	TACTL |= MC1;		    /* Start Timer_a in continious mode */  
    41b6:	b2 d0 20 00 	bis	#32,	&0x0160	;#0x0020
    41ba:	60 01 
}
    41bc:	30 41       	ret			

000041be <ContextSwitch>:
static uint8_t Contexts[NUMTASKS];
static uint8_t CurrentContext = 0;

void ContextSwitch()
{
	Contexts[CurrentContext] = LEDPIN; // store current context
    41be:	5f 42 00 11 	mov.b	&0x1100,r15	
    41c2:	4e 4f       	mov.b	r15,	r14	
    41c4:	de 42 31 00 	mov.b	&0x0031,4354(r14);0x1102(r14)
    41c8:	02 11 
	CurrentContext++;
    41ca:	5f 53       	inc.b	r15		
    41cc:	c2 4f 00 11 	mov.b	r15,	&0x1100	
	// TODO set this to 0xFF for leds
	LEDPIN = 0; // disable all leds
    41d0:	c2 43 31 00 	mov.b	#0,	&0x0031	;r3 As==00
}
    41d4:	30 41       	ret			

000041d6 <ResumeContext>:

void ResumeContext()
{
	CurrentContext--;
    41d6:	5f 42 00 11 	mov.b	&0x1100,r15	
    41da:	7f 53       	add.b	#-1,	r15	;r3 As==11
    41dc:	c2 4f 00 11 	mov.b	r15,	&0x1100	
	LEDPIN = Contexts[CurrentContext]; // resume context
    41e0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    41e2:	3f 50 02 11 	add	#4354,	r15	;#0x1102
    41e6:	e2 4f 31 00 	mov.b	@r15,	&0x0031	
}
    41ea:	30 41       	ret			

000041ec <IntDisable>:

uint16_t IntDisable (void)
{
  uint16_t sw;
    // sw = r2
  asm volatile ("mov.w r2, %0\n\t" : "=r"(sw));
    41ec:	0f 42       	mov	r2,	r15	
  _DINT();
    41ee:	32 c2       	dint			
  return (sw);
}
    41f0:	30 41       	ret			

000041f2 <RestoreSW>:

void RestoreSW (uint16_t sw)
{
    // r2 = sw
  asm volatile ("mov.w %0, r2\n\t" :: "r"(sw));
    41f2:	02 4f       	mov	r15,	r2	
}  
    41f4:	30 41       	ret			

000041f6 <InitTasks>:
void InitTasks (void)
{			
  uint8_t i=NUMTASKS-1; 
  do { 
    Taskp t = &Tasks[i];
    t->Flags = t->Activated = t->Invoked = 0;
    41f6:	3f 40 39 11 	mov	#4409,	r15	;#0x1139
    41fa:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    41fe:	0e 4f       	mov	r15,	r14	
    4200:	3e 53       	add	#-1,	r14	;r3 As==11
    4202:	ce 43 00 00 	mov.b	#0,	0(r14)	;r3 As==00, 0x0000(r14)
    4206:	6e 4e       	mov.b	@r14,	r14	
    4208:	7e f3       	and.b	#-1,	r14	;r3 As==11
    420a:	8f 4e 01 00 	mov	r14,	1(r15)	;0x0001(r15)
    420e:	cf 43 f0 ff 	mov.b	#0,	-16(r15);r3 As==00, 0xfff0(r15)
    4212:	0e 4f       	mov	r15,	r14	
    4214:	3e 50 ef ff 	add	#-17,	r14	;#0xffef
    4218:	ee 4f 00 00 	mov.b	@r15,	0(r14)	;0x0000(r14)
    421c:	6e 4e       	mov.b	@r14,	r14	
    421e:	7e f3       	and.b	#-1,	r14	;r3 As==11
    4220:	8f 4e f1 ff 	mov	r14,	-15(r15);0xfff1(r15)
    4224:	cf 43 e0 ff 	mov.b	#0,	-32(r15);r3 As==00, 0xffe0(r15)
    4228:	0e 4f       	mov	r15,	r14	
    422a:	3e 50 df ff 	add	#-33,	r14	;#0xffdf
    422e:	ee 4f 00 00 	mov.b	@r15,	0(r14)	;0x0000(r14)
    4232:	6e 4e       	mov.b	@r14,	r14	
    4234:	7e f3       	and.b	#-1,	r14	;r3 As==11
    4236:	8f 4e e1 ff 	mov	r14,	-31(r15);0xffe1(r15)
  } while (i--);
}
    423a:	30 41       	ret			

0000423c <RegisterTask>:
 * Each priority level has at most one task.
 */

uint8_t RegisterTask (uint16_t Phasing, uint16_t Period, uint16_t ExecutionTime,
                      void (*TaskFunc) (uint16_t), uint8_t Prio, uint8_t Flags)
{
    423c:	0b 12       	push	r11		
    423e:	0a 12       	push	r10		
    4240:	09 12       	push	r9		
    4242:	05 12       	push	r5		
    4244:	05 41       	mov	r1,	r5	
    4246:	35 50 0a 00 	add	#10,	r5	;#0x000a
    424a:	6b 45       	mov.b	@r5,	r11	
    424c:	59 45 02 00 	mov.b	2(r5),	r9	;0x0002(r5)
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
  Period *=4; // correct to get ms approximately

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
    4250:	7b 90 03 00 	cmp.b	#3,	r11	;#0x0003
    4254:	02 28       	jnc	$+6      	;abs 0x425a
    4256:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4258:	2e 3c       	jmp	$+94     	;abs 0x42b6
{
  uint8_t  rtc = E_SUCCESS;
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
  Period *=4; // correct to get ms approximately
    425a:	0e 5e       	rla	r14		
    425c:	0e 5e       	rla	r14		

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
  if (Period == 0) return (E_WRONGPAR);
    425e:	0e 93       	tst	r14		
    4260:	03 20       	jnz	$+8      	;abs 0x4268
    4262:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    4266:	27 3c       	jmp	$+80     	;abs 0x42b6

uint16_t IntDisable (void)
{
  uint16_t sw;
    // sw = r2
  asm volatile ("mov.w r2, %0\n\t" : "=r"(sw));
    4268:	05 42       	mov	r2,	r5	
  _DINT();
    426a:	32 c2       	dint			
  Period *=4; // correct to get ms approximately

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
  if (Period == 0) return (E_WRONGPAR);
  sw = IntDisable (); 
  Taskp t = &Tasks[Prio]; 
    426c:	7b f3       	and.b	#-1,	r11	;r3 As==11
    426e:	0b 5b       	rla	r11		
    4270:	0b 5b       	rla	r11		
    4272:	0b 5b       	rla	r11		
    4274:	0b 5b       	rla	r11		
    4276:	3b 50 12 11 	add	#4370,	r11	;#0x1112
  if (t->Flags) rtc = E_BUSY; 
    427a:	1a 4b 08 00 	mov	8(r11),	r10	;0x0008(r11)
    427e:	0a 93       	tst	r10		
    4280:	02 24       	jz	$+6      	;abs 0x4286
    4282:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4284:	17 3c       	jmp	$+48     	;abs 0x42b4
                      void (*TaskFunc) (uint16_t), uint8_t Prio, uint8_t Flags)
{
  uint8_t  rtc = E_SUCCESS;
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
    4286:	0f 5f       	rla	r15		
  if (Period == 0) return (E_WRONGPAR);
  sw = IntDisable (); 
  Taskp t = &Tasks[Prio]; 
  if (t->Flags) rtc = E_BUSY; 
  else {
    t->NextRelease = 0 + Phasing;
    4288:	0f 5f       	rla	r15		
    428a:	8b 4f 00 00 	mov	r15,	0(r11)	;0x0000(r11)
    //t->Remaining = Phasing;
    t->Period    = Period; 
    428e:	8b 4e 04 00 	mov	r14,	4(r11)	;0x0004(r11)
    t->NextPendingDeadline = t->NextRelease + Period;
    4292:	2e 5b       	add	@r11,	r14	
    4294:	8b 4e 02 00 	mov	r14,	2(r11)	;0x0002(r11)
    t->Activated = t->Invoked = 0; 
    4298:	cb 4a 07 00 	mov.b	r10,	7(r11)	;0x0007(r11)
    429c:	cb 4a 06 00 	mov.b	r10,	6(r11)	;0x0006(r11)
    t->Taskf     = TaskFunc; 
    42a0:	8b 4c 0c 00 	mov	r12,	12(r11)	;0x000c(r11)
    t->ExecutionTime = ExecutionTime;
    42a4:	8b 4d 0a 00 	mov	r13,	10(r11)	;0x000a(r11)
    t->Flags     = Flags | TRIGGERED;
    42a8:	79 d0 40 00 	bis.b	#64,	r9	;#0x0040
    42ac:	79 f3       	and.b	#-1,	r9	;r3 As==11
    42ae:	8b 49 08 00 	mov	r9,	8(r11)	;0x0008(r11)
    42b2:	4f 4a       	mov.b	r10,	r15	
}

void RestoreSW (uint16_t sw)
{
    // r2 = sw
  asm volatile ("mov.w %0, r2\n\t" :: "r"(sw));
    42b4:	02 45       	mov	r5,	r2	
    t->Flags     = Flags | TRIGGERED;

  }
  RestoreSW (sw);
  return (rtc);
}
    42b6:	35 41       	pop	r5		
    42b8:	39 41       	pop	r9		
    42ba:	3a 41       	pop	r10		
    42bc:	3b 41       	pop	r11		
    42be:	30 41       	ret			

000042c0 <UnRegisterTask>:

uint8_t UnRegisterTask (uint8_t t)
{
  Tasks[t].Flags = 0;
    42c0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    42c2:	0f 5f       	rla	r15		
    42c4:	1f 53       	inc	r15		
    42c6:	0f 5f       	rla	r15		
    42c8:	0f 5f       	rla	r15		
    42ca:	0f 5f       	rla	r15		
    42cc:	8f 43 12 11 	mov	#0,	4370(r15);r3 As==00, 0x1112(r15)
  return (E_SUCCESS);
}  
    42d0:	4f 43       	clr.b	r15		
    42d2:	30 41       	ret			

000042d4 <TimerIntrpt>:
    NextInterruptTime = CandidateValue;
  }
}

interrupt (TIMERA0_VECTOR) TimerIntrpt (void)
{
    42d4:	0f 12       	push	r15		
    42d6:	0e 12       	push	r14		
    42d8:	0d 12       	push	r13		
    42da:	0c 12       	push	r12		
  int i;
  
  StartTracking(TT_TIMER_INTERRUPT);
    42dc:	4f 43       	clr.b	r15		
    42de:	b0 12 9e 46 	call	#0x469e	
  
  ContextSwitch();
    42e2:	b0 12 be 41 	call	#0x41be	
  
  SetLeds(WHITE, 1);
    42e6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    42e8:	6f 42       	mov.b	#4,	r15	;r2 As==10
    42ea:	b0 12 90 41 	call	#0x4190	
    42ee:	1e 42 42 11 	mov	&0x1142,r14	

  while(NextInterruptTime <= TAR)
    42f2:	1b 3c       	jmp	$+56     	;abs 0x432a
    42f4:	3f 40 12 11 	mov	#4370,	r15	;#0x1112
  {
    NextInterruptTime = CandidateValue;
  }
}

interrupt (TIMERA0_VECTOR) TimerIntrpt (void)
    42f8:	3d 43       	mov	#-1,	r13	;r3 As==11

    for (i = 0; i < NUMTASKS; i++) // loop through all task to see which need to be scheduled
    {
      Taskp t = &Tasks[i];

      if (t->Flags & TRIGGERED) // check if timer available
    42fa:	bf b0 40 00 	bit	#64,	8(r15)	;#0x0040, 0x0008(r15)
    42fe:	08 00 
    4300:	0c 24       	jz	$+26     	;abs 0x431a
      {
        if (t->NextRelease <= TAR) // task needs to be scheduled
    4302:	2e 4f       	mov	@r15,	r14	
    4304:	82 9e 70 01 	cmp	r14,	&0x0170	
    4308:	05 28       	jnc	$+12     	;abs 0x4314
        {
          t->Activated++; // set task to pending
    430a:	df 53 06 00 	inc.b	6(r15)		;0x0006(r15)
          t->NextRelease += t->Period; // set next release time
    430e:	9f 5f 04 00 	add	4(r15),	0(r15)	;0x0004(r15), 0x0000(r15)
    4312:	00 00 
        }
        DetermineNextInterruptTime(t->NextRelease); // this might be the next interrupt time
    4314:	2e 4f       	mov	@r15,	r14	
  return (E_SUCCESS);
}  

static void DetermineNextInterruptTime (CandidateValue)
{
  if (CandidateValue < NextInterruptTime)
    4316:	0e 9d       	cmp	r13,	r14	
    4318:	01 28       	jnc	$+4      	;abs 0x431c
    431a:	0e 4d       	mov	r13,	r14	
    431c:	3f 50 10 00 	add	#16,	r15	;#0x0010

  while(NextInterruptTime <= TAR)
  {
    NextInterruptTime = 0xFFFF; // reset next intterupt time so it can be determined again

    for (i = 0; i < NUMTASKS; i++) // loop through all task to see which need to be scheduled
    4320:	3f 90 42 11 	cmp	#4418,	r15	;#0x1142
    4324:	02 24       	jz	$+6      	;abs 0x432a
    4326:	0d 4e       	mov	r14,	r13	
    4328:	e8 3f       	jmp	$-46     	;abs 0x42fa
  
  ContextSwitch();
  
  SetLeds(WHITE, 1);

  while(NextInterruptTime <= TAR)
    432a:	82 9e 70 01 	cmp	r14,	&0x0170	
    432e:	e2 2f       	jc	$-58     	;abs 0x42f4
    4330:	82 4e 42 11 	mov	r14,	&0x1142	
        DetermineNextInterruptTime(t->NextRelease); // this might be the next interrupt time
      }
    }    
  } 
 
  TACCR0 = NextInterruptTime; // set next interrupt time
    4334:	82 4e 72 01 	mov	r14,	&0x0172	

  SetLeds(WHITE, 0);
    4338:	4e 43       	clr.b	r14		
    433a:	6f 42       	mov.b	#4,	r15	;r2 As==10
    433c:	b0 12 90 41 	call	#0x4190	
  StopTracking(TT_TIMER_INTERRUPT);
    4340:	4f 43       	clr.b	r15		
    4342:	b0 12 aa 46 	call	#0x46aa	
  
  StartTracking(TT_SCHEDULER);
    4346:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4348:	b0 12 9e 46 	call	#0x469e	
  SetLeds(BROWN, 1);
    434c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    434e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4350:	b0 12 90 41 	call	#0x4190	

  CALL_SCHEDULER;
    4354:	3f 40 12 11 	mov	#4370,	r15	;#0x1112
    4358:	b0 12 ae 44 	call	#0x44ae	

  SetLeds(BROWN, 0);
    435c:	4e 43       	clr.b	r14		
    435e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4360:	b0 12 90 41 	call	#0x4190	

  ResumeContext();
    4364:	b0 12 d6 41 	call	#0x41d6	

  StopTracking(TT_SCHEDULER);
    4368:	5f 43       	mov.b	#1,	r15	;r3 As==01
    436a:	b0 12 aa 46 	call	#0x46aa	
  PrintResults();
    436e:	b0 12 c6 46 	call	#0x46c6	
}
    4372:	3c 41       	pop	r12		
    4374:	3d 41       	pop	r13		
    4376:	3e 41       	pop	r14		
    4378:	3f 41       	pop	r15		
    437a:	00 13       	reti			

0000437c <Scheduler_NP_FP>:
	t->Flags ^= BUSY_EXEC;
	/* ---------------------------------------------------------------- */
}

void Scheduler_NP_FP(Task Tasks[])
{
    437c:	0b 12       	push	r11		
    437e:	0a 12       	push	r10		
    4380:	0b 4f       	mov	r15,	r11	
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
	/* ---------------------------------------------------------------- */
}

void Scheduler_NP_FP(Task Tasks[])
    4382:	0a 4f       	mov	r15,	r10	
    4384:	3a 50 30 00 	add	#48,	r10	;#0x0030
	int i;
	static uint8_t Busy = 0;

	for (i = 0; i < NUMTASKS; i++)
	{
		StartTracking(TT_SCHEDULER);
    4388:	5f 43       	mov.b	#1,	r15	;r3 As==01
    438a:	b0 12 9e 46 	call	#0x469e	
		Taskp t = &Tasks[i];
		if (t->Flags & BUSY_EXEC)
    438e:	1f 4b 08 00 	mov	8(r11),	r15	;0x0008(r11)
    4392:	3f f0 00 02 	and	#512,	r15	;#0x0200
    4396:	06 24       	jz	$+14     	;abs 0x43a4
		{
			StopTracking(TT_SCHEDULER);
    4398:	5f 43       	mov.b	#1,	r15	;r3 As==01
    439a:	b0 12 aa 46 	call	#0x46aa	
			PrintResults();
    439e:	b0 12 c6 46 	call	#0x46c6	
			break;
    43a2:	39 3c       	jmp	$+116    	;abs 0x4416
		}
		else
		{
			if (!(t->Flags & TRIGGERED))
    43a4:	1e 4b 08 00 	mov	8(r11),	r14	;0x0008(r11)
    43a8:	3e f0 40 00 	and	#64,	r14	;#0x0040
    43ac:	0e 9f       	cmp	r15,	r14	
    43ae:	04 20       	jnz	$+10     	;abs 0x43b8
			{
				t->Activated = t->Invoked;
    43b0:	5f 4b 07 00 	mov.b	7(r11),	r15	;0x0007(r11)
    43b4:	cb 4f 06 00 	mov.b	r15,	6(r11)	;0x0006(r11)
			}
			StopTracking(TT_SCHEDULER);
    43b8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43ba:	b0 12 aa 46 	call	#0x46aa	
			PrintResults();
    43be:	b0 12 c6 46 	call	#0x46c6	

			while (t->Activated != t->Invoked && !Busy)
    43c2:	1e 3c       	jmp	$+62     	;abs 0x4400
			{
				StartTracking(TT_SCHEDULER);
    43c4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43c6:	b0 12 9e 46 	call	#0x469e	
				t->Flags |= BUSY_EXEC;
    43ca:	bb d0 00 02 	bis	#512,	8(r11)	;#0x0200, 0x0008(r11)
    43ce:	08 00 
				_EINT();
    43d0:	32 d2       	eint			
				StopTracking(TT_SCHEDULER);
    43d2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43d4:	b0 12 aa 46 	call	#0x46aa	
				Busy = 1;
    43d8:	d2 43 06 11 	mov.b	#1,	&0x1106	;r3 As==01

static void ExecuteTask(Taskp t)
{
	/* ----------------------- INSERT CODE HERE ----------------------- */

	t->Invoked++;
    43dc:	db 53 07 00 	inc.b	7(r11)		;0x0007(r11)
	t->Taskf(t->ExecutionTime); // execute task
    43e0:	1f 4b 0a 00 	mov	10(r11),r15	;0x000a(r11)
    43e4:	9b 12 0c 00 	call	12(r11)	;0x000c(r11)
	t->Flags ^= BUSY_EXEC;
    43e8:	bb e0 00 02 	xor	#512,	8(r11)	;#0x0200, 0x0008(r11)
    43ec:	08 00 
				t->Flags |= BUSY_EXEC;
				_EINT();
				StopTracking(TT_SCHEDULER);
				Busy = 1;
				ExecuteTask(t);
				Busy = 0;
    43ee:	c2 43 06 11 	mov.b	#0,	&0x1106	;r3 As==00
				StartTracking(TT_SCHEDULER);
    43f2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43f4:	b0 12 9e 46 	call	#0x469e	
				_DINT();
    43f8:	32 c2       	dint			
				StopTracking(TT_SCHEDULER);
    43fa:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43fc:	b0 12 aa 46 	call	#0x46aa	
				t->Activated = t->Invoked;
			}
			StopTracking(TT_SCHEDULER);
			PrintResults();

			while (t->Activated != t->Invoked && !Busy)
    4400:	db 9b 07 00 	cmp.b	7(r11),	6(r11)	;0x0007(r11), 0x0006(r11)
    4404:	06 00 
    4406:	03 24       	jz	$+8      	;abs 0x440e
    4408:	c2 93 06 11 	tst.b	&0x1106	
    440c:	db 27       	jz	$-72     	;abs 0x43c4
    440e:	3b 50 10 00 	add	#16,	r11	;#0x0010
{
	/* ----------------------- INSERT CODE HERE ----------------------- */
	int i;
	static uint8_t Busy = 0;

	for (i = 0; i < NUMTASKS; i++)
    4412:	0b 9a       	cmp	r10,	r11	
    4414:	b9 23       	jnz	$-140    	;abs 0x4388
				StopTracking(TT_SCHEDULER);
			}
		}
	}
	/* ---------------------------------------------------------------- */
}
    4416:	3a 41       	pop	r10		
    4418:	3b 41       	pop	r11		
    441a:	30 41       	ret			

0000441c <Scheduler_P_FP>:
  
  t->Flags &= ~BUSY_EXEC; // this task is done busy executing
}

void Scheduler_P_FP (Task Tasks[])
{ 
    441c:	0b 12       	push	r11		
    441e:	0a 12       	push	r10		
    4420:	09 12       	push	r9		
    4422:	08 12       	push	r8		
    4424:	0a 4f       	mov	r15,	r10	
    4426:	4d 43       	clr.b	r13		
{
  t->Invoked++; // increment invoked counter
  t->Flags |= BUSY_EXEC; // set this task to busy executing
  
  StopTracking(TT_SCHEDULER);
  SetLeds(BROWN, 0);
    4428:	68 43       	mov.b	#2,	r8	;r3 As==10
    ScheduleAgain = 0; // reset ScheduleAgain flag
    NextTaskIndex = -1; // reset NextTaskIndex

    for (i = 0; i < NUMTASKS; i++) // loop through all task to see which need to be scheduled
    {
      Taskp t = &Tasks[i];
    442a:	4e 4d       	mov.b	r13,	r14	
    442c:	0e 5e       	rla	r14		
    442e:	0e 5e       	rla	r14		
    4430:	0e 5e       	rla	r14		
    4432:	0e 5e       	rla	r14		
    4434:	0e 5a       	add	r10,	r14	

      if (t->Flags & TRIGGERED) // check if task is available
    4436:	be b0 40 00 	bit	#64,	8(r14)	;#0x0040, 0x0008(r14)
    443a:	08 00 
    443c:	30 24       	jz	$+98     	;abs 0x449e
      {
        if (t->Flags & BUSY_EXEC)
    443e:	19 4e 08 00 	mov	8(r14),	r9	;0x0008(r14)
    4442:	39 f0 00 02 	and	#512,	r9	;#0x0200
    4446:	2e 20       	jnz	$+94     	;abs 0x44a4
        {
          // this task was already executing, no need to invoke it again, exit scheduler
          break;
        }  
        else if (t->Activated != t->Invoked) // check if task needs to be executed
    4448:	de 9e 07 00 	cmp.b	7(r14),	6(r14)	;0x0007(r14), 0x0006(r14)
    444c:	06 00 
    444e:	27 24       	jz	$+80     	;abs 0x449e
      }
    }

    if (NextTaskIndex >= 0)
    {
      ExecuteTask(&Tasks[NextTaskIndex]);
    4450:	8d 11       	sxt	r13		
    4452:	0d 5d       	rla	r13		
    4454:	0d 5d       	rla	r13		
    4456:	0d 5d       	rla	r13		
    4458:	0d 5d       	rla	r13		
    445a:	0b 4a       	mov	r10,	r11	
    445c:	0b 5d       	add	r13,	r11	
#include "Led.h"
#include "TimeTracking.h"

static void ExecuteTask (Taskp t)
{
  t->Invoked++; // increment invoked counter
    445e:	db 53 07 00 	inc.b	7(r11)		;0x0007(r11)
  t->Flags |= BUSY_EXEC; // set this task to busy executing
    4462:	bb d0 00 02 	bis	#512,	8(r11)	;#0x0200, 0x0008(r11)
    4466:	08 00 
  
  StopTracking(TT_SCHEDULER);
    4468:	5f 43       	mov.b	#1,	r15	;r3 As==01
    446a:	b0 12 aa 46 	call	#0x46aa	
  SetLeds(BROWN, 0);
    446e:	4e 49       	mov.b	r9,	r14	
    4470:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4472:	b0 12 90 41 	call	#0x4190	

  _EINT(); // because we are a preemptive scheduler, we should enable interrupts
    4476:	32 d2       	eint			
  t->Taskf(t->ExecutionTime); // execute task
    4478:	1f 4b 0a 00 	mov	10(r11),r15	;0x000a(r11)
    447c:	9b 12 0c 00 	call	12(r11)	;0x000c(r11)
  _DINT(); // we are done with task execution, we don't want our scheduler to get interrupted
    4480:	32 c2       	dint			

  AddJobExecution();
    4482:	b0 12 c0 46 	call	#0x46c0	
  StartTracking(TT_SCHEDULER);
    4486:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4488:	b0 12 9e 46 	call	#0x469e	
  SetLeds(BROWN, 1);
    448c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    448e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4490:	b0 12 90 41 	call	#0x4190	
  
  t->Flags &= ~BUSY_EXEC; // this task is done busy executing
    4494:	bb f0 ff fd 	and	#-513,	8(r11)	;#0xfdff, 0x0008(r11)
    4498:	08 00 
    449a:	4d 43       	clr.b	r13		
    449c:	c6 3f       	jmp	$-114    	;abs 0x442a
  do 
  {
    ScheduleAgain = 0; // reset ScheduleAgain flag
    NextTaskIndex = -1; // reset NextTaskIndex

    for (i = 0; i < NUMTASKS; i++) // loop through all task to see which need to be scheduled
    449e:	5d 53       	inc.b	r13		
    44a0:	48 9d       	cmp.b	r13,	r8	
    44a2:	c3 2f       	jc	$-120    	;abs 0x442a
    {
      ExecuteTask(&Tasks[NextTaskIndex]);
      ScheduleAgain = 1; // because we executed a task, we should call scheduler again
    } 
  } while (ScheduleAgain); // check whether scheduler should be executed again
}
    44a4:	38 41       	pop	r8		
    44a6:	39 41       	pop	r9		
    44a8:	3a 41       	pop	r10		
    44aa:	3b 41       	pop	r11		
    44ac:	30 41       	ret			

000044ae <Scheduler_P_EDF>:
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
}

void Scheduler_P_EDF(Task Tasks[])
{
    44ae:	0b 12       	push	r11		
    44b0:	0a 12       	push	r10		
    44b2:	09 12       	push	r9		
    44b4:	08 12       	push	r8		
    44b6:	07 12       	push	r7		
    44b8:	06 12       	push	r6		
    44ba:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    44be:	08 4f       	mov	r15,	r8	
    44c0:	27 43       	mov	#2,	r7	;r3 As==10
    44c2:	35 3c       	jmp	$+108    	;abs 0x452e
	for (i = 0; i < NUMTASKS; i++)
	{
		int j;
		for (j = 0; j < NUMTASKS - i - 1; j++)
		{
			if (Tasks[j].NextRelease > Tasks[j + 1].NextRelease)
    44c4:	2f 4a       	mov	@r10,	r15	
	t->Invoked++;
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
}

void Scheduler_P_EDF(Task Tasks[])
    44c6:	09 4a       	mov	r10,	r9	
    44c8:	39 50 10 00 	add	#16,	r9	;#0x0010
	for (i = 0; i < NUMTASKS; i++)
	{
		int j;
		for (j = 0; j < NUMTASKS - i - 1; j++)
		{
			if (Tasks[j].NextRelease > Tasks[j + 1].NextRelease)
    44cc:	89 9f 00 00 	cmp	r15,	0(r9)	;0x0000(r9)
    44d0:	27 2c       	jc	$+80     	;abs 0x4520
			{
				Task T = Tasks[j + 1];
    44d2:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    44d6:	0e 49       	mov	r9,	r14	
    44d8:	0f 41       	mov	r1,	r15	
    44da:	b0 12 f2 46 	call	#0x46f2	
				if (Tasks[j].NextRelease == Tasks[j + 1].NextRelease)
    44de:	2e 4a       	mov	@r10,	r14	
    44e0:	2f 49       	mov	@r9,	r15	
    44e2:	0e 9f       	cmp	r15,	r14	
    44e4:	10 20       	jnz	$+34     	;abs 0x4506
				{
					//T.Flags |= BUSY_EXEC;

					if (Tasks[j].Prio > Tasks[j + 1].Prio)
    44e6:	da 9a 0e 00 	cmp.b	14(r10),30(r10)	;0x000e(r10), 0x001e(r10)
    44ea:	1e 00 
    44ec:	0c 2c       	jc	$+26     	;abs 0x4506
					{
						Tasks[j + 1] = Tasks[j];
    44ee:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    44f2:	0e 4a       	mov	r10,	r14	
    44f4:	0f 49       	mov	r9,	r15	
    44f6:	b0 12 f2 46 	call	#0x46f2	
						Tasks[j] = T;
    44fa:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    44fe:	0e 41       	mov	r1,	r14	
    4500:	0f 4a       	mov	r10,	r15	
    4502:	b0 12 f2 46 	call	#0x46f2	
					}
				}

				Tasks[j + 1] = Tasks[j];
    4506:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    450a:	0e 4a       	mov	r10,	r14	
    450c:	0f 4a       	mov	r10,	r15	
    450e:	0f 5d       	add	r13,	r15	
    4510:	b0 12 f2 46 	call	#0x46f2	
				Tasks[j] = T;
    4514:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    4518:	0e 41       	mov	r1,	r14	
    451a:	0f 4a       	mov	r10,	r15	
    451c:	b0 12 f2 46 	call	#0x46f2	

	//Bubblesort on descending order
	for (i = 0; i < NUMTASKS; i++)
	{
		int j;
		for (j = 0; j < NUMTASKS - i - 1; j++)
    4520:	16 53       	inc	r6		
    4522:	0a 49       	mov	r9,	r10	
    4524:	06 97       	cmp	r7,	r6	
    4526:	ce 3b       	jl	$-98     	;abs 0x44c4
    4528:	37 53       	add	#-1,	r7	;r3 As==11
			}
		}
	}*/

	//Bubblesort on descending order
	for (i = 0; i < NUMTASKS; i++)
    452a:	37 93       	cmp	#-1,	r7	;r3 As==11
    452c:	04 24       	jz	$+10     	;abs 0x4536
    452e:	0b 48       	mov	r8,	r11	
    4530:	0a 48       	mov	r8,	r10	
    4532:	06 43       	clr	r6		
    4534:	f7 3f       	jmp	$-16     	;abs 0x4524
	t->Invoked++;
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
}

void Scheduler_P_EDF(Task Tasks[])
    4536:	38 50 30 00 	add	#48,	r8	;#0x0030
		}
	}*/

	for (i = 0; i < NUMTASKS; i++)
	{
		if (Tasks[i].Flags & BUSY_EXEC)
    453a:	bb b0 00 02 	bit	#512,	8(r11)	;#0x0200, 0x0008(r11)
    453e:	08 00 
    4540:	2a 20       	jnz	$+86     	;abs 0x4596
		{
			break;
		}
		else
		{
			if (Tasks[i].Activated != Tasks[i].Invoked)
    4542:	5f 4b 07 00 	mov.b	7(r11),	r15	;0x0007(r11)
    4546:	cb 9f 06 00 	cmp.b	r15,	6(r11)	;0x0006(r11)
    454a:	21 24       	jz	$+68     	;abs 0x458e
			{
				if (Tasks[i].Flags & TRIGGERED)
    454c:	bb b0 40 00 	bit	#64,	8(r11)	;#0x0040, 0x0008(r11)
    4550:	08 00 
    4552:	1b 24       	jz	$+56     	;abs 0x458a
				{
					StartTracking(TT_SCHEDULER);
    4554:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4556:	b0 12 9e 46 	call	#0x469e	
					Tasks[i].Flags |= BUSY_EXEC;
    455a:	bb d0 00 02 	bis	#512,	8(r11)	;#0x0200, 0x0008(r11)
    455e:	08 00 
					_EINT();
    4560:	32 d2       	eint			
					StopTracking(TT_SCHEDULER);
    4562:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4564:	b0 12 aa 46 	call	#0x46aa	
#include "TimeTracking.h"
#include "Led.h"

static void ExecuteTask(Taskp t)
{
	t->Invoked++;
    4568:	db 53 07 00 	inc.b	7(r11)		;0x0007(r11)
	t->Taskf(t->ExecutionTime); // execute task
    456c:	1f 4b 0a 00 	mov	10(r11),r15	;0x000a(r11)
    4570:	9b 12 0c 00 	call	12(r11)	;0x000c(r11)
	t->Flags ^= BUSY_EXEC;
    4574:	bb e0 00 02 	xor	#512,	8(r11)	;#0x0200, 0x0008(r11)
    4578:	08 00 
					StartTracking(TT_SCHEDULER);
					Tasks[i].Flags |= BUSY_EXEC;
					_EINT();
					StopTracking(TT_SCHEDULER);
					ExecuteTask(&Tasks[i]);
					StartTracking(TT_SCHEDULER);
    457a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    457c:	b0 12 9e 46 	call	#0x469e	
					_DINT();
    4580:	32 c2       	dint			
					StopTracking(TT_SCHEDULER);
    4582:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4584:	b0 12 aa 46 	call	#0x46aa	
    4588:	02 3c       	jmp	$+6      	;abs 0x458e
				}
				else
				{
					Tasks[i].Activated = Tasks[i].Invoked;
    458a:	cb 4f 06 00 	mov.b	r15,	6(r11)	;0x0006(r11)
    458e:	3b 50 10 00 	add	#16,	r11	;#0x0010
				}
			}
		}
	}*/

	for (i = 0; i < NUMTASKS; i++)
    4592:	0b 98       	cmp	r8,	r11	
    4594:	d2 23       	jnz	$-90     	;abs 0x453a
					Tasks[i].Activated = Tasks[i].Invoked;
				}
			}
		}
	}
}
    4596:	31 50 10 00 	add	#16,	r1	;#0x0010
    459a:	36 41       	pop	r6		
    459c:	37 41       	pop	r7		
    459e:	38 41       	pop	r8		
    45a0:	39 41       	pop	r9		
    45a2:	3a 41       	pop	r10		
    45a4:	3b 41       	pop	r11		
    45a6:	30 41       	ret			

000045a8 <Scheduler_NP_EDF>:
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
}

void Scheduler_NP_EDF(Task Tasks[])
{
    45a8:	0b 12       	push	r11		
    45aa:	0a 12       	push	r10		
    45ac:	09 12       	push	r9		
    45ae:	04 12       	push	r4		
    45b0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
	//Init Q array of Task pointers, so we don't change the original Task array
	if (Init != 1)
	{
		for (i = 0; i < NUMTASKS; i++)
		{
			Q[i] = &Tasks[i];
    45b4:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    45b8:	0e 4f       	mov	r15,	r14	
    45ba:	3e 50 10 00 	add	#16,	r14	;#0x0010
    45be:	81 4e 02 00 	mov	r14,	2(r1)	;0x0002(r1)
    45c2:	3f 50 20 00 	add	#32,	r15	;#0x0020
    45c6:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
	uint8_t i;
	Taskp Q[NUMTASKS];
	uint8_t Init;

	//Init Q array of Task pointers, so we don't change the original Task array
	if (Init != 1)
    45ca:	2c 43       	mov	#2,	r12	;r3 As==10
    45cc:	22 3c       	jmp	$+70     	;abs 0x4612
	for (i = 0; i < NUMTASKS; i++)
	{
		int j;
		for (j = 0; j < NUMTASKS - i - 1; j++)
		{
			if (Q[j]->NextPendingDeadline != Q[j + 1]->NextPendingDeadline)
    45ce:	2d 4f       	mov	@r15,	r13	
    45d0:	19 4d 02 00 	mov	2(r13),	r9	;0x0002(r13)
    45d4:	1b 53       	inc	r11		
    45d6:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    45da:	1a 4e 02 00 	mov	2(r14),	r10	;0x0002(r14)
    45de:	09 9a       	cmp	r10,	r9	
    45e0:	0a 24       	jz	$+22     	;abs 0x45f6
			{
				if (Q[j]->NextPendingDeadline > Q[j + 1]->NextPendingDeadline)
    45e2:	1a 4d 02 00 	mov	2(r13),	r10	;0x0002(r13)
    45e6:	8e 9a 02 00 	cmp	r10,	2(r14)	;0x0002(r14)
    45ea:	0d 2c       	jc	$+28     	;abs 0x4606
				{
					Taskp T = Q[j];
					Q[j] = Q[j + 1];
    45ec:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
					Q[j + 1] = T;
    45f0:	8f 4d 02 00 	mov	r13,	2(r15)	;0x0002(r15)
    45f4:	08 3c       	jmp	$+18     	;abs 0x4606
				}
			}
			else
			{
				if (Q[j+1]->Prio > Q[j]->Prio)
    45f6:	dd 9e 0e 00 	cmp.b	14(r14),14(r13)	;0x000e(r14), 0x000e(r13)
    45fa:	0e 00 
    45fc:	04 2c       	jc	$+10     	;abs 0x4606
				{
					Taskp T = Q[j+1];
					Q[j+1] = Q[j];
    45fe:	8f 4d 02 00 	mov	r13,	2(r15)	;0x0002(r15)
					Q[j] = T;
    4602:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    4606:	2f 53       	incd	r15		

	//Bubblesort on descending order
	for (i = 0; i < NUMTASKS; i++)
	{
		int j;
		for (j = 0; j < NUMTASKS - i - 1; j++)
    4608:	0b 9c       	cmp	r12,	r11	
    460a:	e1 3b       	jl	$-60     	;abs 0x45ce
    460c:	3c 53       	add	#-1,	r12	;r3 As==11
		}
		Init = 1;
	}

	//Bubblesort on descending order
	for (i = 0; i < NUMTASKS; i++)
    460e:	3c 93       	cmp	#-1,	r12	;r3 As==11
    4610:	04 24       	jz	$+10     	;abs 0x461a
    4612:	04 41       	mov	r1,	r4	
    4614:	0f 41       	mov	r1,	r15	
    4616:	0b 43       	clr	r11		
    4618:	f7 3f       	jmp	$-16     	;abs 0x4608
	t->Invoked++;
	t->Taskf(t->ExecutionTime); // execute task
	t->Flags ^= BUSY_EXEC;
}

void Scheduler_NP_EDF(Task Tasks[])
    461a:	0a 41       	mov	r1,	r10	
    461c:	3a 50 06 00 	add	#6,	r10	;#0x0006

	static uint8_t Busy = 0;

	for (i = 0; i < NUMTASKS; i++)
	{
		if (Q[i]->Flags & BUSY_EXEC)
    4620:	2b 44       	mov	@r4,	r11	
    4622:	1f 4b 08 00 	mov	8(r11),	r15	;0x0008(r11)
    4626:	3f f0 00 02 	and	#512,	r15	;#0x0200
    462a:	32 20       	jnz	$+102    	;abs 0x4690
		{
			break;
		}
		else
		{
			if (!(Q[i]->Flags & TRIGGERED))
    462c:	1e 4b 08 00 	mov	8(r11),	r14	;0x0008(r11)
    4630:	3e f0 40 00 	and	#64,	r14	;#0x0040
    4634:	0e 9f       	cmp	r15,	r14	
    4636:	04 20       	jnz	$+10     	;abs 0x4640
			{
				Q[i]->Activated = Q[i]->Invoked;
    4638:	5f 4b 07 00 	mov.b	7(r11),	r15	;0x0007(r11)
    463c:	cb 4f 06 00 	mov.b	r15,	6(r11)	;0x0006(r11)
			}

			if (Q[i]->Activated != Q[i]->Invoked && (Busy == 0))
    4640:	db 9b 07 00 	cmp.b	7(r11),	6(r11)	;0x0007(r11), 0x0006(r11)
    4644:	06 00 
    4646:	21 24       	jz	$+68     	;abs 0x468a
    4648:	c2 93 07 11 	tst.b	&0x1107	
    464c:	1e 20       	jnz	$+62     	;abs 0x468a
			{
				StartTracking(TT_SCHEDULER);
    464e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4650:	b0 12 9e 46 	call	#0x469e	
				Q[i]->Flags |= BUSY_EXEC;
    4654:	bb d0 00 02 	bis	#512,	8(r11)	;#0x0200, 0x0008(r11)
    4658:	08 00 
				_EINT();
    465a:	32 d2       	eint			
				StopTracking(TT_SCHEDULER);
    465c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    465e:	b0 12 aa 46 	call	#0x46aa	
				Busy = 1;
    4662:	d2 43 07 11 	mov.b	#1,	&0x1107	;r3 As==01
#include "TimeTracking.h"
#include "Led.h"

static void ExecuteTask(Taskp t)
{
	t->Invoked++;
    4666:	db 53 07 00 	inc.b	7(r11)		;0x0007(r11)
	t->Taskf(t->ExecutionTime); // execute task
    466a:	1f 4b 0a 00 	mov	10(r11),r15	;0x000a(r11)
    466e:	9b 12 0c 00 	call	12(r11)	;0x000c(r11)
	t->Flags ^= BUSY_EXEC;
    4672:	bb e0 00 02 	xor	#512,	8(r11)	;#0x0200, 0x0008(r11)
    4676:	08 00 
				Q[i]->Flags |= BUSY_EXEC;
				_EINT();
				StopTracking(TT_SCHEDULER);
				Busy = 1;
				ExecuteTask(Q[i]);
				Busy = 0;
    4678:	c2 43 07 11 	mov.b	#0,	&0x1107	;r3 As==00
				StartTracking(TT_SCHEDULER);
    467c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    467e:	b0 12 9e 46 	call	#0x469e	
				_DINT();
    4682:	32 c2       	dint			
				StopTracking(TT_SCHEDULER);
    4684:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4686:	b0 12 aa 46 	call	#0x46aa	
    468a:	24 53       	incd	r4		
		}
	}

	static uint8_t Busy = 0;

	for (i = 0; i < NUMTASKS; i++)
    468c:	04 9a       	cmp	r10,	r4	
    468e:	c8 23       	jnz	$-110    	;abs 0x4620
				_DINT();
				StopTracking(TT_SCHEDULER);
			}
		}
	}
}
    4690:	31 50 06 00 	add	#6,	r1	;#0x0006
    4694:	34 41       	pop	r4		
    4696:	39 41       	pop	r9		
    4698:	3a 41       	pop	r10		
    469a:	3b 41       	pop	r11		
    469c:	30 41       	ret			

0000469e <StartTracking>:
static uint16_t Totals[TT_MAX];
static uint8_t JobsExecuted;

void StartTracking(uint8_t index)
{
    StartTimes[index] = TAR;
    469e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    46a0:	0f 5f       	rla	r15		
    46a2:	9f 42 70 01 	mov	&0x0170,4360(r15);0x1108(r15)
    46a6:	08 11 
}
    46a8:	30 41       	ret			

000046aa <StopTracking>:

void StopTracking(uint8_t index)
{
    Totals[index] += TAR - StartTimes[index];
    46aa:	7f f3       	and.b	#-1,	r15	;r3 As==11
    46ac:	0f 5f       	rla	r15		
    46ae:	1e 42 70 01 	mov	&0x0170,r14	
    46b2:	1e 5f 0c 11 	add	4364(r15),r14	;0x110c(r15)
    46b6:	1e 8f 08 11 	sub	4360(r15),r14	;0x1108(r15)
    46ba:	8f 4e 0c 11 	mov	r14,	4364(r15);0x110c(r15)
}
    46be:	30 41       	ret			

000046c0 <AddJobExecution>:

void AddJobExecution()
{
    JobsExecuted++;
    46c0:	d2 53 10 11 	inc.b	&0x1110	
}
    46c4:	30 41       	ret			

000046c6 <PrintResults>:

void PrintResults()
{
    P1OUT = Totals[TT_TIMER_INTERRUPT] & 0xFF;
    46c6:	3e 40 0c 11 	mov	#4364,	r14	;#0x110c
    46ca:	2d 4e       	mov	@r14,	r13	
    46cc:	c2 4d 21 00 	mov.b	r13,	&0x0021	
    P2OUT = Totals[TT_TIMER_INTERRUPT] >> 8;
    46d0:	3f 4e       	mov	@r14+,	r15	
    46d2:	0f 4d       	mov	r13,	r15	
    46d4:	8f 10       	swpb	r15		
    46d6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    46d8:	c2 4f 29 00 	mov.b	r15,	&0x0029	

    P3OUT = Totals[TT_SCHEDULER] & 0xFF;
    46dc:	2f 4e       	mov	@r14,	r15	
    46de:	c2 4f 19 00 	mov.b	r15,	&0x0019	
    P4OUT = Totals[TT_SCHEDULER] >> 8;
    46e2:	8f 10       	swpb	r15		
    46e4:	7f f3       	and.b	#-1,	r15	;r3 As==11
    46e6:	c2 4f 1d 00 	mov.b	r15,	&0x001d	

    P6OUT = JobsExecuted;
    46ea:	d2 42 10 11 	mov.b	&0x1110,&0x0035	
    46ee:	35 00 
    46f0:	30 41       	ret			

000046f2 <memcpy>:
    46f2:	0b 12       	push	r11		
    46f4:	0a 12       	push	r10		
    46f6:	09 12       	push	r9		
    46f8:	08 12       	push	r8		
    46fa:	07 12       	push	r7		
    46fc:	0d 93       	tst	r13		
    46fe:	1f 24       	jz	$+64     	;abs 0x473e
    4700:	0a 4f       	mov	r15,	r10	
    4702:	0c 4e       	mov	r14,	r12	
    4704:	0f 9e       	cmp	r14,	r15	
    4706:	1b 24       	jz	$+56     	;abs 0x473e
    4708:	0f 9e       	cmp	r14,	r15	
    470a:	1f 2c       	jc	$+64     	;abs 0x474a
    470c:	0b 4e       	mov	r14,	r11	
    470e:	0b df       	bis	r15,	r11	
    4710:	1b f3       	and	#1,	r11	;r3 As==01
    4712:	44 20       	jnz	$+138    	;abs 0x479c
    4714:	08 4d       	mov	r13,	r8	
    4716:	12 c3       	clrc			
    4718:	08 10       	rrc	r8		
    471a:	1d f3       	and	#1,	r13	;r3 As==01
    471c:	08 93       	tst	r8		
    471e:	0b 24       	jz	$+24     	;abs 0x4736
    4720:	0b 48       	mov	r8,	r11	
    4722:	09 4c       	mov	r12,	r9	
    4724:	0e 4a       	mov	r10,	r14	
    4726:	be 49 00 00 	mov	@r9+,	0(r14)	;0x0000(r14)
    472a:	2e 53       	incd	r14		
    472c:	3b 53       	add	#-1,	r11	;r3 As==11
    472e:	fb 23       	jnz	$-8      	;abs 0x4726
    4730:	08 58       	rla	r8		
    4732:	0c 58       	add	r8,	r12	
    4734:	0a 58       	add	r8,	r10	
    4736:	0d 93       	tst	r13		
    4738:	02 24       	jz	$+6      	;abs 0x473e
    473a:	ea 4c 00 00 	mov.b	@r12,	0(r10)	;0x0000(r10)
    473e:	37 41       	pop	r7		
    4740:	38 41       	pop	r8		
    4742:	39 41       	pop	r9		
    4744:	3a 41       	pop	r10		
    4746:	3b 41       	pop	r11		
    4748:	30 41       	ret			
    474a:	0e 5d       	add	r13,	r14	
    474c:	09 4f       	mov	r15,	r9	
    474e:	09 5d       	add	r13,	r9	
    4750:	0c 49       	mov	r9,	r12	
    4752:	0c de       	bis	r14,	r12	
    4754:	1c f3       	and	#1,	r12	;r3 As==01
    4756:	38 20       	jnz	$+114    	;abs 0x47c8
    4758:	08 4d       	mov	r13,	r8	
    475a:	12 c3       	clrc			
    475c:	08 10       	rrc	r8		
    475e:	1d f3       	and	#1,	r13	;r3 As==01
    4760:	08 93       	tst	r8		
    4762:	11 24       	jz	$+36     	;abs 0x4786
    4764:	0a 48       	mov	r8,	r10	
    4766:	0b 4e       	mov	r14,	r11	
    4768:	0c 49       	mov	r9,	r12	
    476a:	2b 83       	decd	r11		
    476c:	2c 83       	decd	r12		
    476e:	ac 4b 00 00 	mov	@r11,	0(r12)	;0x0000(r12)
    4772:	3a 53       	add	#-1,	r10	;r3 As==11
    4774:	fa 23       	jnz	$-10     	;abs 0x476a
    4776:	0c 48       	mov	r8,	r12	
    4778:	0c 11       	rra	r12		
    477a:	0c 43       	clr	r12		
    477c:	0c 10       	rrc	r12		
    477e:	0c 88       	sub	r8,	r12	
    4780:	0c 5c       	rla	r12		
    4782:	0e 5c       	add	r12,	r14	
    4784:	09 5c       	add	r12,	r9	
    4786:	0d 93       	tst	r13		
    4788:	da 27       	jz	$-74     	;abs 0x473e
    478a:	d9 4e ff ff 	mov.b	-1(r14),-1(r9)	;0xffff(r14), 0xffff(r9)
    478e:	ff ff 
    4790:	37 41       	pop	r7		
    4792:	38 41       	pop	r8		
    4794:	39 41       	pop	r9		
    4796:	3a 41       	pop	r10		
    4798:	3b 41       	pop	r11		
    479a:	30 41       	ret			
    479c:	0a 4e       	mov	r14,	r10	
    479e:	0a ef       	xor	r15,	r10	
    47a0:	1a f3       	and	#1,	r10	;r3 As==01
    47a2:	2b 24       	jz	$+88     	;abs 0x47fa
    47a4:	0b 4d       	mov	r13,	r11	
    47a6:	0d 43       	clr	r13		
    47a8:	08 4d       	mov	r13,	r8	
    47aa:	0c 43       	clr	r12		
    47ac:	0a 4f       	mov	r15,	r10	
    47ae:	0a 5c       	add	r12,	r10	
    47b0:	09 4e       	mov	r14,	r9	
    47b2:	09 5c       	add	r12,	r9	
    47b4:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    47b8:	1c 53       	inc	r12		
    47ba:	0b 9c       	cmp	r12,	r11	
    47bc:	f7 23       	jnz	$-16     	;abs 0x47ac
    47be:	0a 4f       	mov	r15,	r10	
    47c0:	0a 5b       	add	r11,	r10	
    47c2:	0c 4e       	mov	r14,	r12	
    47c4:	0c 5b       	add	r11,	r12	
    47c6:	aa 3f       	jmp	$-170    	;abs 0x471c
    47c8:	0c 49       	mov	r9,	r12	
    47ca:	0c ee       	xor	r14,	r12	
    47cc:	1c f3       	and	#1,	r12	;r3 As==01
    47ce:	03 20       	jnz	$+8      	;abs 0x47d6
    47d0:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    47d4:	20 2c       	jc	$+66     	;abs 0x4816
    47d6:	07 4d       	mov	r13,	r7	
    47d8:	0d 43       	clr	r13		
    47da:	08 4d       	mov	r13,	r8	
    47dc:	0a 47       	mov	r7,	r10	
    47de:	0b 4e       	mov	r14,	r11	
    47e0:	0c 49       	mov	r9,	r12	
    47e2:	3c 53       	add	#-1,	r12	;r3 As==11
    47e4:	3b 53       	add	#-1,	r11	;r3 As==11
    47e6:	ec 4b 00 00 	mov.b	@r11,	0(r12)	;0x0000(r12)
    47ea:	3a 53       	add	#-1,	r10	;r3 As==11
    47ec:	fa 23       	jnz	$-10     	;abs 0x47e2
    47ee:	0c 47       	mov	r7,	r12	
    47f0:	3c e3       	inv	r12		
    47f2:	1c 53       	inc	r12		
    47f4:	09 5c       	add	r12,	r9	
    47f6:	0e 5c       	add	r12,	r14	
    47f8:	b3 3f       	jmp	$-152    	;abs 0x4760
    47fa:	1b 43       	mov	#1,	r11	;r3 As==01
    47fc:	0b 9d       	cmp	r13,	r11	
    47fe:	14 2c       	jc	$+42     	;abs 0x4828
    4800:	0c 4e       	mov	r14,	r12	
    4802:	1c f3       	and	#1,	r12	;r3 As==01
    4804:	2b 43       	mov	#2,	r11	;r3 As==10
    4806:	0b 8c       	sub	r12,	r11	
    4808:	08 4d       	mov	r13,	r8	
    480a:	08 8b       	sub	r11,	r8	
    480c:	0d 48       	mov	r8,	r13	
    480e:	12 c3       	clrc			
    4810:	08 10       	rrc	r8		
    4812:	1d f3       	and	#1,	r13	;r3 As==01
    4814:	ca 3f       	jmp	$-106    	;abs 0x47aa
    4816:	07 4e       	mov	r14,	r7	
    4818:	17 f3       	and	#1,	r7	;r3 As==01
    481a:	08 4d       	mov	r13,	r8	
    481c:	08 87       	sub	r7,	r8	
    481e:	0d 48       	mov	r8,	r13	
    4820:	12 c3       	clrc			
    4822:	08 10       	rrc	r8		
    4824:	1d f3       	and	#1,	r13	;r3 As==01
    4826:	da 3f       	jmp	$-74     	;abs 0x47dc
    4828:	0d 4a       	mov	r10,	r13	
    482a:	08 4a       	mov	r10,	r8	
    482c:	be 3f       	jmp	$-130    	;abs 0x47aa

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 40 30 40 30 40 30 40 30 40 30 40 d4 42 30 40     0@0@0@0@0@0@.B0@
    fff0:	30 40 30 40 30 40 30 40 30 40 30 40 30 40 00 40     0@0@0@0@0@0@0@.@
